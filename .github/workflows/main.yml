name: Setup ngrok and Remote Desktop

on:
  workflow_dispatch:  # Manual trigger only

jobs:
  setup-ngrok:
    runs-on: windows-latest
    timeout-minutes: 360  # Max allowed: 6 hours

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Cache ngrok
        id: cache-ngrok
        uses: actions/cache@v3
        with:
          path: ngrok.exe
          key: ngrok-latest

      - name: Download and extract ngrok
        if: steps.cache-ngrok.outputs.cache-hit != 'true'
        run: |
          $downloadUrl = "https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip"
          $zipFile = "ngrok.zip"
          Write-Host "Downloading ngrok from $downloadUrl..."
          Invoke-WebRequest $downloadUrl -OutFile $zipFile
          Expand-Archive $zipFile -DestinationPath . -Force
          Remove-Item $zipFile

      - name: Update ngrok
        run: .\ngrok.exe update

      - name: Authenticate ngrok
        run: .\ngrok.exe authtoken ${{ secrets.NGROK_AUTH_TOKEN }}
        env:
          NGROK_AUTH_TOKEN: ${{ secrets.NGROK_AUTH_TOKEN }}

      - name: Enable Remote Desktop
        run: |
          Write-Host "Enabling Remote Desktop..."
          Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server" -Name "fDenyTSConnections" -Value 0
          Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
          Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" -Name "UserAuthentication" -Value 1

      - name: Set Password for runneradmin (using secret)
        run: |
          Write-Host "Setting password for runneradmin..."
          $user = Get-LocalUser -Name "runneradmin"
          if ($user.Enabled -eq $false) { Enable-LocalUser -Name "runneradmin" }
          $secPass = ConvertTo-SecureString "${{ secrets.RDP_PASSWORD }}" -AsPlainText -Force
          Set-LocalUser -Name "runneradmin" -Password $secPass
        env:
          RDP_PASSWORD: ${{ secrets.RDP_PASSWORD }}

      - name: Start ngrok TCP tunnel and get connection info
        id: ngrok-tunnel
        run: |
          Write-Host "Starting ngrok TCP tunnel for RDP port 3389..."
          Start-Process -FilePath .\ngrok.exe -ArgumentList "tcp 3389" -RedirectStandardOutput ngrok.log -RedirectStandardError ngrok.log -WindowStyle Hidden

          # Wait for the tunnel to become active and get the public URL
          $apiUrl = "http://127.0.0.1:4040/api/tunnels"
          $maxRetries = 12
          $retryDelay = 5 # seconds
          $tcpAddr = $null

          for ($i = 0; $i -lt $maxRetries; $i++) {
            try {
              Write-Host "Attempting to get ngrok tunnel info (retry $($i+1)/$maxRetries)..."
              $response = Invoke-RestMethod -Uri $apiUrl
              $tcpAddr = ($response.tunnels | Where-Object { $_.proto -eq "tcp" }).public_url
              if ($tcpAddr) {
                Write-Host "Ngrok tunnel is active!"
                break
              }
            } catch {
              Write-Host "Ngrok API not responding yet. Waiting for $retryDelay seconds..."
            }
            Start-Sleep -Seconds $retryDelay
          }

          if (-not $tcpAddr) {
            Write-Error "Failed to get ngrok tunnel info after multiple retries."
            throw "Ngrok tunnel not established."
          }

          Write-Output "::set-output name=tcp_address::$tcpAddr"
          Write-Host "::notice::Connect using: $tcpAddr"
          Write-Host "To connect: mstsc /v:$tcpAddr"

      - name: Keep Alive (6 hours)
        run: |
          Write-Host "Keeping the job alive for 6 hours..."
          Start-Sleep -Seconds (360 * 60) # 360 minutes * 60 seconds
        continue-on-error: true
